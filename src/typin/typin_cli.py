# -*- coding: utf-8 -*-
"""Main module."""
import argparse
import datetime
import logging
import os
import sys
import time
import traceback

from typin import type_inferencer

def _new_file_path(root, file_path, makedirs=False, new_ext=''):
    """Returns a new path of file_path below root.
    If makedirs then the directory(ies) for the return value will be created.
    """
    path_list = os.path.abspath(os.path.normpath(file_path)).split(os.sep)
    path_list.pop(0) # Root
    if new_ext:
        path_list[-1] = os.path.splitext(path_list[-1])[0] + new_ext
    out_path = os.path.join(root, *path_list)
    out_dir = os.path.dirname(out_path)
    if makedirs and not os.path.exists(out_dir):
        os.makedirs(out_dir)
    return out_path

def write_all_stub_files(ti, stubs_dir):
    """Writes out stubs files.

    :param ti: The type inferencer.
    :type ti: ``typin.type_inferencer.TypeInferencer``

    :param stubs_dir: The directory to write to.
    :type stubs_dir: ``str``

    :return: ``NoneType``
    """
    assert stubs_dir != ''
    stubs_dir = os.path.abspath(stubs_dir)
    print(' write_all_stub_files() '.center(75, '-'))
    for file_path in sorted(ti.file_paths()):
        if os.path.splitext(file_path)[1] == '.py':
            out_path = _new_file_path(stubs_dir, file_path, makedirs=True)
            print(out_path)
            with open(out_path, 'w') as stream:
                now = datetime.datetime.now()
                stream.write('# Generated by typin_cli.py on {:s}\n'.format(now.strftime('%c')))
                try:
                    stream.write(ti.pretty_format(file_path, add_line_number_as_comment=True))
                except Exception as err:
                    logging.error('Could not write docstring to {:s}: {!r:s}: {:s}'.format(out_path, type(err), str(err)))
                    logging.error(''.join(traceback.format_exception(*sys.exc_info())))
                stream.write('\n')

def dump_docstrings(ti, style, stream=sys.stdout, reverse_lines=False):
    stream.write(' dump_docstrings '.center(75, '-'))
    stream.write('\n')
    # dict of {file_path : { namespace : { function_name : FunctionTypes, ...}, ...}
    for file_path in sorted(ti.file_paths()):
        stream.write('File: {:s}\n'.format(file_path))
        try:
            docstring_map = ti.docstring_map(file_path, style=style)
        except Exception as err:
            logging.error('Can not write docstring for file "{:s}": {!r:s}, {:s}'.format(file_path, type(err), str(err)))
            logging.error(''.join(traceback.format_exception(*sys.exc_info())))
        else:
            if reverse_lines:
                keys = reversed(sorted(docstring_map.keys()))
            else:
                keys = sorted(docstring_map.keys())
            for lineno in keys:
                namespace, function_name, docstring = docstring_map[lineno]
                prefix = '    '
                if namespace != '':
                    prefix *= 1 + len(namespace.split('.'))
                stream.write('Namespace: "{:s}"\n'.format(namespace))
                stream.write('Function: "{:s}" [{:d}]:\n'.format(function_name, lineno))
                for aline in docstring.split('\n'):
                    stream.write('{:s}{:s}\n'.format(prefix, aline))
                stream.write('\n')
    stream.write(' END: dump_docstrings '.center(75, '-'))
    stream.write('\n')

def insert_docstrings(ti, doc_dir, style):
    """Writes out source files with documentation strings.

    :param ti: The type inferencer.
    :type ti: ``typin.type_inferencer.TypeInferencer``

    :param doc_dir: The directory to write to.
    :type doc_dir: ``str``

    :return: ``NoneType``
    """
    # dict of {file_path : { namespace : { function_name : FunctionTypes, ...}, ...}
    for file_path in sorted(ti.file_paths()):
        out_path = _new_file_path(doc_dir, file_path, makedirs=True)
        src_lines = ti.insert_docstrings(file_path, style=style)
        with open(out_path, 'w') as f:
            for aline in src_lines:
                f.write(aline)

def dump_type_inferencer(ti, stream=sys.stdout):
    stream.write(' ti.dump() '.center(75, '-'))
    stream.write('\n')
    ti.dump(stream=stream)
    stream.write(' END: ti.dump() '.center(75, '-'))
    stream.write('\n')

def print_pretty_format(ti, root_path, stream=sys.stdout):
    stream.write(' ti.pretty_format() '.center(75, '-'))
    stream.write('\n')
    file_paths = ti.file_paths_filtered(root_path, relative=True)
    for key, file_path in file_paths:
#         print(os.path.join(cli_args.stubs, file_path))
        stream.write(file_path)
        stream.write('\n')
        stream.write(ti.pretty_format(key))
        stream.write('\n')
    stream.write(' END: ti.pretty_format() '.center(75, '-'))
    stream.write('\n')

def compile_and_exec(filename, *args, **kwargs):
    print('TRACE: compile_and_exec()', filename, args, kwargs)
    sys.argv = [filename] + list(args)
    logging.debug('typein_cli.compile_and_exec({:s})'.format(filename))
    with open(filename) as f_obj:
        src = f_obj.read()
        logging.debug('typein_cli.compile_and_exec() read {:d} lines'.format(src.count('\n')))
        code = compile(src, filename, 'exec')
        with type_inferencer.TypeInferencer() as ti:
            try:
                exec(code, globals())#, locals())
            except SystemExit:
                # Trap CLI code that calls exit() or sys.exit()
                pass
    return ti

class BaseClass:
    def __init__(self):
        pass

class ExampleClass(BaseClass):
    """An example class with a couple of methods that we exercise."""
    def __init__(self, first_name, last_name):
        super(ExampleClass, self).__init__()
        self.first_name = first_name
        self.last_name = last_name

    def name(self):
        ret = '{:s}, {:s}'.format(self.last_name, self.first_name)
        return ret

def example_function(x):
    return 2 * x

def test():
    with type_inferencer.TypeInferencer() as ti:
        _val = example_function(12)
        jane_doe = ExampleClass('Jane', 'Doe')
        jane_doe.name()
    file_paths = ti.file_paths_filtered()
    print(' typin_cli.test() ti.pretty_format() '.center(75, '-'))
    for file_path in file_paths:
        print(file_path)
        print(ti.pretty_format(file_path))
    print(' typin_cli.test() ti.dump() '.center(75, '-'))
    ti.dump()

def main():
    """Command line version of typin which executes arbitrary Python code and
    for each function records all the types called, returned and raised.
    For example::

        python typin_cli.py --stubs=stubs -- example.py 'foo bar baz'

    This will execute ``example.py`` with the options ``foo bar baz`` under the
    control of typin and write all the type annotations to the stubs/ directory.
    """
    start_time = time.time()
    start_clock = time.clock()
    program_version = "v%s" % '0.1.0'
    program_shortdesc = 'typin_cli - Infer types of Python functions.'
    program_license = """%s
  Created by Paul Ross on 2017-10-25. Copyright 2017. All rights reserved.
  Version: %s Licensed under MIT License
USAGE
""" % (program_shortdesc, program_version)
    parser = argparse.ArgumentParser(description=program_license,
                            formatter_class=argparse.RawDescriptionHelpFormatter)
#     parser.add_argument("-c", action="store_true", dest="plot_conditional", default=False,
#                       help="Add conditionally included files to the plots. [default: %(default)s]")
#     parser.add_argument("-d", "--dump", action="append", dest="dump", default=[],
#                       help="""Dump output, additive. Can be:
# C - Conditional compilation graph.
# F - File names encountered and their count.
# I - Include graph.
# M - Macro environment.
# T - Token count.
# R - Macro dependencies as an input to DOT.
# [default: %(default)s]""")
#     parser.add_argument("-g", "--glob", action='append', default=[],
#             help="Pattern match to use when processing directories. [default: %(default)s] i.e. every file.")
#     parser.add_argument("--heap", action="store_true", dest="heap", default=False,
#                       help="Profile memory usage. [default: %(default)s]")
#     parser.add_argument("-k", "--keep-going", action="store_true",
#                          dest="keep_going", default=False,
#                          help="Keep going. [default: %(default)s]")
    parser.add_argument(
            "-l", "--loglevel",
            type=int,
            dest="loglevel",
            default=30,
            help="Log Level (debug=10, info=20, warning=30, error=40, critical=50)" \
            " [default: %(default)s]"
        )
#     parser.add_argument("-o", "--output",
#                          type=str,
#                          dest="output",
#                          default="out",
#                          help="Output directory. [default: %(default)s]")
#     parser.add_argument("-p", action="store_true", dest="ignore_pragma", default=False,
#                       help="Ignore pragma statements. [default: %(default)s]")
#     parser.add_argument("-r", "--recursive", action="store_true", dest="recursive",
#                          default=False,
#                       help="Recursively process directories. [default: %(default)s]")
#     parser.add_argument("-t", "--dot", action="store_true", dest="include_dot",
#                          default=False,
#                       help="""Write an DOT include dependency table and execute DOT
# on it to create a SVG file. [default: %(default)s]""")
#     parser.add_argument("-G", action="store_true", dest="gcc_extensions",
#                          default=False,
#                       help="""Support GCC extensions. Currently only #include_next. [default: %(default)s]""")
    parser.add_argument("-s", "--stubs",
                         type=str,
                         dest="stubs",
                         default="",
                         help="Directory to write stubs files. [default: %(default)s]")
    parser.add_argument("-w", "--write-docstrings",
                         type=str,
                         dest="write_docstrings",
                         default="",
                         help="Directory to write source code with docstrings. [default: %(default)s]")
    parser.add_argument("--docstring-style",
                         type=str,
                         dest="docstring_style",
                         default=type_inferencer.TypeInferencer.DOCSTRING_STYLE_DEFAULT,
                         help="Style of docstrings, can be: {:s}. [default: %(default)s]".format(
                            ', '.join(
                                ['\'{:s}\''.format(v) for v in type_inferencer.TypeInferencer.DOCSTRING_STYLES_AVAILABLE]
                                )
                            )
                        )
    parser.add_argument("-r", "--root",
                         type=str,
                         dest="root",
                         default=".",
                         help="Root path of the Python packages to generate stub files for. [default: %(default)s]")
    parser.add_argument(dest="program",
                        help="Python target file to be compiled and executed.")
    parser.add_argument(dest="argstring",
                        help="Argument as a string to give to the target."
                        " Prefix this with '--' to avoid them getting consumed by typin_cli.py")
    cli_args = parser.parse_args()
    logFormat = '%(asctime)s %(levelname)-8s %(message)s'
    logging.basicConfig(level=cli_args.loglevel,
                        format=logFormat,
                        # datefmt='%y-%m-%d % %H:%M:%S',
                        stream=sys.stdout)
#     print('sys.argv:', sys.argv)
#     sys.argv = cli_args.args[1:]
#     print('sys.argv:', sys.argv)
#     print('cli_args', cli_args)
    root_path = os.path.abspath(os.path.normpath(cli_args.root))
#     test()
    target_args = cli_args.argstring.split(' ')
    ti = compile_and_exec(cli_args.program, *target_args)
    # Output
    print_pretty_format(ti, root_path)
    dump_type_inferencer(ti)
    if cli_args.stubs:
        write_all_stub_files(ti, cli_args.stubs)
    dump_docstrings(ti, cli_args.docstring_style)
    if cli_args.write_docstrings:
        insert_docstrings(ti, cli_args.write_docstrings, cli_args.docstring_style)
    print('TypeInferencer event count:', ti.event_counter)
    print(' CPU time = {:8.3f} (S)'.format(time.time() - start_time))
    print('CPU clock = {:8.3f} (S)'.format(time.clock() - start_clock))
    print('Bye, bye!')
    return 0

if __name__ == '__main__':
    sys.exit(main())
